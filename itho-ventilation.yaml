substitutions:
  device_name: itho-ventilation  # Used for hostname (must use hyphens, no underscores)
  device_prefix: "ITHO"          # Unique prefix, used for entity names (home assistant IDs) (underscores allowed)

esphome:
  name: ${device_name}
  friendly_name: ITHO ventilation
  on_boot:
    then:
      - lambda: |-
          get_mac_address_raw(id(my_device_id));
          ESP_LOGI("itho", "Device MAC: %s", format_hex_pretty(id(my_device_id), 6).c_str());

esp32:
  board: esp32dev
  framework:
    type: esp-idf

spi:
  clk_pin: GPIO18 # CC1101 SCK
  miso_pin: GPIO19 # CC1101 MISO/GDO1
  mosi_pin: GPIO23 # CC1101 MOSI

# Enable logging
logger:
  level: DEBUG

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  log_topic: esp/logs/${device_name}

ota:
  - platform: esphome
    password: "f65ab2932751d08bf5775d8058830d88"

web_server:
   port: 80

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# =============================================================================
# ALLOWED DEVICE IDs CONFIGURATION
# =============================================================================
# Configure which ITHO devices are allowed to control this ESP32.
# To find device IDs, monitor logs when a device sends a command.
# The ESP will show "Ignored packet from unknown [type]: XX.YY.ZZ"

# Format: "XX.YY.ZZ Device Name" - one entry per line
# Each device ID is 3 bytes in hexadecimal format (XX.YY.ZZ)
# followed by a space and then the device name/description

globals:
  # ALLOWED REMOTE IDs (Physical remotes and virtual remotes like Home Assistant)
  - id: allowed_remotes_config
    type: std::vector<std::string>
    restore_value: no
    initial_value: '{"51.36.35 Badkamer", "5F.53.40 Home assistant", "A8.86.D4 ESP test remote"}'

  # ALLOWED VENTILATION UNIT IDs
  - id: allowed_units_config
    type: std::vector<std::string>
    restore_value: no
    initial_value: '{"94.D8.F9 Ventilatie unit"}'

# =============================================================================
# DEVICE-SPECIFIC CONFIGURATION ENDS HERE
# =============================================================================
# Everything above this line is device-specific and should be customized for
# each device (device name, prefix, WiFi, MQTT, GPIO pins, etc.).
#
# Everything below this line is SHARED configuration that can be copied as-is
# to other devices. Only the 'device_prefix' substitution at the top needs to
# be changed to ensure unique IDs in Home Assistant.
# =============================================================================

# Store device ID for RF transmission
  # Device ID bytes (MAC address of device. Use last 3 bytes which are probably unique)
  - id: my_device_id
    type: uint8_t[6]
    restore_value: no
    initial_value: '{0, 0, 0, 0, 0, 0}'
  - id: device_type
    type: uint8_t
    restore_value: no
    initial_value: '22'  # 0x16 = 22 decimal, standard ITHO remote type
  - id: packet_counter
    type: uint8_t
    restore_value: yes
    initial_value: '0'
  - id: timeout
    type: int32_t
    restore_value: no
    initial_value: '0'
  - id: sync_bytes
    type: uint8_t[2]
    restore_value: no
    initial_value: '{0xAB, 0xFE}'  # Same as cc1101.sync1, cc1101.sync0
  - id: itho_header
    type: uint8_t[5]
    restore_value: no
    initial_value: '{0x00, 0xB3, 0x2A, 0xAB, 0x2A}'

# https://esphome.io/components/cc1101/
# Configuration based on IthoCC1101::initReceiveMessage()
# See: https://github.com/letscontrolit/ESPEasy/blob/15830d38268eb28c3fe234413a81f6cf015aeda9/lib/Itho/IthoCC1101.cpp#L238
cc1101:
  cs_pin: GPIO22
  # Base/carrier frequency: 868.299866MHz
  frequency: 868.2999MHz
  # 2-FSK modulation
  modulation_type: 2-FSK
  # Symbol rate: MDMCFG4=0x5A, MDMCFG3=0x83 = 38.3835 kBaud
  symbol_rate: 38383
  # Filter bandwidth: ~203kHz (based on MDMCFG4=0x5A)
  filter_bandwidth: 203kHz
  # Frequency deviation: DEVIATN=0x50 = 50.78125kHz
  fsk_deviation: 50kHz
  # Output power
  output_power: 10
  # Enable packet mode
  gdo0_pin: GPIO16
  packet_mode: true
  # Packet mode configuration
  num_preamble: 4  # 8 bytes; Note: ITHO expects 7 bytes
  sync_mode: 16/16  # MDMCFG2=0x02 = 16-bit sync word
  sync1: 0xAB # Same as global sync_bytes[0]
  sync0: 0xFE # Same as global sync_bytes[1]
  packet_length: 63  # Fixed packet length (sync bytes removed by CC1101)
  crc_enable: false  # CRC disabled in ITHO
  whitening: false   # Data whitening disabled
  on_packet:
    then:
      - lambda: |-
          // ITHO packet decoder based on IthoCC1101::messageDecode()
          // Decode Manchester-like encoding with 1-0 pattern every 8 bits

          if (x.size() != 63) {
            ESP_LOGW("itho", "Invalid packet length: %d", x.size());
            return;
          }

          for (int i = 0; i < sizeof(id(itho_header)); ++i) {
            if (x[i] != id(itho_header)[i]) {
              if (rssi > -90) {  // Silently ignore non ITHO packets with a low rssi
                ESP_LOGD("itho", "rssi: %.1f dBm, Non itho data: %s", rssi, format_hex_pretty(x).c_str());
              }
              return;
            }
          }

          ESP_LOGD("itho", "rssi: %.1f dBm, lqi: %u, data: %s", rssi, lqi, format_hex_pretty(x).c_str());

          // Decoded data buffer
          uint8_t decoded[32] = {0};
          uint8_t decoded_len = 0;

          // Decoding parameters - start decoding after ITHO header
          const int STARTBYTE = sizeof(id(itho_header));
          uint8_t out_i = 0;         // byte index
          uint8_t out_j = 4;         // bit index (start at bit 4)
          uint8_t in_bitcounter = 0; // process per 10 input bits

          // Decode the packet starting from STARTBYTE
          for (int i = STARTBYTE; i < x.size(); i++) {
            for (int j = 7; j >= 0; j--) {
              // Select even bits (0, 2, 4, 6) for output
              if (in_bitcounter == 0 || in_bitcounter == 2 ||
                  in_bitcounter == 4 || in_bitcounter == 6) {
                uint8_t bit = (x[i] >> j) & 0x01;
                decoded[out_i] |= (bit << out_j);
                out_j++;
                if (out_j > 7) { out_j = 0; }
                if (out_j == 4) {
                  out_i++;
                  if (out_i >= 32) break;
                }
              }

              in_bitcounter++;
              if (in_bitcounter > 9) { in_bitcounter = 0; }
            }
            if (out_i >= 32) break;
          }
          decoded_len = out_i;

          // Log decoded packet
          ESP_LOGD("itho", "Received message: %s", format_hex_pretty(decoded, decoded_len).c_str());

          // Check for valid ITHO packet (min 14 bytes)
          if (decoded_len < 14) {
            ESP_LOGW("itho", "Decoded packet too short");
            return;
          }

          // Check if this is a status message from the unit (starts with 0x1A)
          // Format: 1A.94.D8.F9.94.D8.F9.XX.31.D9.11.00.06.YY...
          if (decoded[0] == 0x1A && decoded[12] == 0x06) {
            // Parse allowed unit IDs from config vector (format: "XX.YY.ZZ Name")
            std::string source_name = "";
            std::string device_id = format_hex_pretty(&decoded[1], 3);
            
            for (const auto& entry : id(allowed_units_config)) {
              // Compare device ID (format: "XX.YY.ZZ Name")
              if (entry.substr(0, 8) == device_id) {
                source_name = entry.substr(9);  // Extract name (everything after "XX.YY.ZZ ")
                break;
              }
            }

            if (source_name.empty()) {
              ESP_LOGW("itho", "Ignored packet from unknown ventilation unit: %s", device_id.c_str());
              return;  // Reject commands from unknown devices
            }

            // Byte 13 contains speed indicator
            // Percentage calculation: 0x20 = 0%, 0x80 = 100%
            uint8_t speed_byte = decoded[13];

            // Calculate percentage (0-200 mapped to 0-100%)
            float speed = speed_byte / 2.0;
            ESP_LOGI("itho", "Received fan speed: %.1f (Source: %s)", speed, source_name.c_str());
            id(fan_speed).publish_state(speed);

            // Clear command if current speed no longer matches the requested command
            if (speed_byte >= 0x80) {
              if ((id(last_command).state != "High") && (id(last_command).state != "Timer")) {
                id(last_command).publish_state("");
              }
            } else if (speed_byte >= 0x38) {
              if (id(last_command).state != "Medium") {
                id(last_command).publish_state("");
              }
            } else if (speed_byte >= 0x30) {
              if (id(last_command).state != "Low") {
                id(last_command).publish_state("");
              }
            }
          }
          // Remote command packets: check bytes 5-10 against command patterns
          // Based on IthoCC1101::checkIthoCommand() and command byte arrays
          // Low:    0x22, 0xF1, 0x03, 0x00, 0x02, 0x04
          // Medium: 0x22, 0xF1, 0x03, 0x00, 0x03, 0x04
          // High:   0x22, 0xF1, 0x03, 0x00, 0x04, 0x04
          // Timer:  0x22, 0xF3, 0x03, 0x00, 0x00, 0x0A/14/1E
          else if (decoded_len >= 11 && decoded[5] == 0x22 && decoded[7] == 0x03) {
            // Parse allowed remote IDs from config vector (format: "XX.YY.ZZ Name")
            std::string source_name = "";
            std::string device_id = format_hex_pretty(&decoded[1], 3);
            
            for (const auto& entry : id(allowed_remotes_config)) {
              // Compare device ID (format: "XX.YY.ZZ Name")
              if (entry.substr(0, 8) == device_id) {
                source_name = entry.substr(9);  // Extract name (everything after "XX.YY.ZZ ")
                break;
              }
            }

            if (source_name.empty()) {
              ESP_LOGW("itho", "Ignored packet from unknown remote unit: %s", device_id.c_str());
              return;  // Reject commands from unknown devices
            }

            const char* command = nullptr;
            // Timer: byte[6]==0xF3, byte[9]==0x00, byte[10]==0x0A/0x14/0x1E (10, 20 or 30 minutes)
            if (decoded[6] == 0xF3 && decoded[9] == 0x00) {
              command = "Timer";
              id(timeout) = decoded[10] * 60;
              if (! id(timer_tick).is_running()) {
                id(timer_tick).execute();  // Start the timer
              }
            }
            // Low/Medium/High: byte[6]==0xF1, byte[10]==0x04
            else if (decoded[6] == 0xF1 && decoded[10] == 0x04) {
              id(timeout) = 0;  // Disable the timer
              // Distinguish by byte[9]
              if (decoded[9] == 0x02) {
                command = "Low";
              } else if (decoded[9] == 0x03) {
                command = "Medium";
              } else if (decoded[9] == 0x04) {
                command = "High";
              }
            }

            // Update sensors for remote commands
            if (command != nullptr) {
              ESP_LOGI("itho", "Command: %s (Source: %s)", command, source_name.c_str());
              id(controller_name).publish_state(source_name);
              id(last_command).publish_state(command);
            }
          }

# Sensors for ITHO status
sensor:
  - platform: template
    name: "${device_prefix} Ventilation Speed"
    id: fan_speed
    unit_of_measurement: "%"
    icon: "mdi:fan"
    accuracy_decimals: 0

  - platform: uptime
    type: seconds
    name: "${device_prefix} Uptime"

  - platform: wifi_signal
    name: "${device_prefix} WiFi Signal"

# Text sensors for ITHO commands
text_sensor:
  - platform: template
    name: "${device_prefix} Last Command"
    id: last_command
    icon: "mdi:fan-clock"

  - platform: template
    name: "${device_prefix} Last Control Source"
    id: controller_name
    icon: "mdi:remote"

  - platform: template
    name: "${device_prefix} Timer"
    id: timer
    icon: "mdi:timer"

# Buttons for pairing and control
button:
  - platform: template
    name: "${device_prefix} Pair Remote"
    icon: "mdi:link-plus"
    on_press:
      - script.execute:
          id: send_join_command

  - platform: template
    name: "${device_prefix} Leave Remote"
    icon: "mdi:link-off"
    on_press:
      - script.execute:
          id: send_leave_command

  - platform: template
    name: "${device_prefix} Low"
    icon: "mdi:fan-speed-1"
    on_press:
      - script.execute:
          id: send_command
          command_byte: 0x02

  - platform: template
    name: "${device_prefix} Medium"
    icon: "mdi:fan-speed-2"
    on_press:
      - script.execute:
          id: send_command
          command_byte: 0x03

  - platform: template
    name: "${device_prefix} High"
    icon: "mdi:fan-speed-3"
    on_press:
      - script.execute:
          id: send_command
          command_byte: 0x04

# Scripts
script:
  - id: send_packet_data
    mode: queued
    parameters:
      packet_data: std::vector<uint8_t>
      transmit_count: uint8_t
      retransmit_delay: uint8_t
    then:
      - cc1101.send_packet:
          data: !lambda |-
            // Return the full packet data (packet_data is copied by value, safe to use)
            return packet_data;
      - delay: !lambda |-
          return retransmit_delay;
      - lambda: |-
          if (transmit_count > 1) {
            // Queue next transmission with delay
            id(send_packet_data).execute(packet_data, transmit_count - 1, retransmit_delay);
          }


  - id: send_payload
    mode: single
    parameters:
      payload: uint8_t*
      payload_size: uint8_t
      end_byte: uint8_t
      transmit_count: uint8_t   # generate packet data once and transmit exactly this many times
      retransmit_delay: uint8_t
    then:
      - lambda: |-
          ESP_LOGD("itho", "Send message: %s", format_hex_pretty(payload, payload_size).c_str());

          // Encode message with Manchester-like encoding
          // Start with message header
          // Note: CC1101 will automatically add 8 bytes of 0xAA preamble (num_preamble: 4) and sync bytes (sync1 and sync0)
          std::vector<uint8_t> packet_data(63, 0);  // Initialize vector with 63 zeros
          uint8_t out_bytecounter{0};
          for (; out_bytecounter < sizeof(id(itho_header)); out_bytecounter++) {
            packet_data[out_bytecounter] = (id(itho_header)[out_bytecounter]);
          }
          // Encoded buffer starts after the sync + header)

          // Manchester-like encoding of payload
          // Pattern: for each data bit, insert 1-0 pattern every 8 bits
          uint8_t out_bitcounter = 0;           // Bit position within current output byte (0-7)
          uint8_t out_patterncounter = 0;       // Bit counter to add "10" pattern after every 8 bits
          uint8_t bitSelect = 4;                // Bit position of the input byte (4-7, 0-3)
          uint8_t out_shift = 7;                // Bit shift for positioning in output byte (7-0)

          // Process each byte of payload data
          for (uint8_t dataByte = 0; dataByte < payload_size; dataByte++) {
            // Process all 8 bits of this data byte
            for (uint8_t dataBit = 0; dataBit < 8; dataBit++) {
              // Check if new output byte is needed
              if (out_bitcounter == 8) {
                out_bytecounter++;
                out_bitcounter = 0;
                if (out_bytecounter >= 63) {
                  ESP_LOGW("itho", "too much data to encode");
                  return;
                }
              }

              // Insert "10" pattern every 8 bits
              if (out_patterncounter == 8) {
                out_patterncounter = 0;
                packet_data[out_bytecounter] |= (1 << out_shift);
                out_shift--;
                out_bitcounter++;
                // Note: To set bit to 0, correct operation would be: packet_data[out_bytecounter] &= ~(1 << out_shift);
                // However, packet_data is zero-initialized, so this is a no-op and omitted for clarity
                if (out_shift == 0) {
                  out_shift = 8;
                }
                out_shift--;
                out_bitcounter++;
              }

              // Check if new output byte is needed (after pattern insertion)
              if (out_bitcounter == 8) {
                out_bytecounter++;
                out_bitcounter = 0;
                if (out_bytecounter >= 63) {
                  ESP_LOGW("itho", "too much data to encode");
                  return;
                }
              }

              // Extract bit from input data
              uint8_t bit = (payload[dataByte] & (1 << bitSelect)) >> bitSelect;
              bitSelect++;
              if (bitSelect == 8) {
                bitSelect = 0;
              }

              // Write the even bit (data bit)
              packet_data[out_bytecounter] |= (bit << out_shift);
              out_shift--;
              out_bitcounter++;
              out_patterncounter++;

              // Write the odd bit (inverted data bit)
              bit = ~bit & 0x01;
              packet_data[out_bytecounter] |= (bit << out_shift);
              if (out_shift == 0) {
                out_shift = 8;
              }
              out_shift--;
              out_bitcounter++;
              out_patterncounter++;
            }
          }

          // Add closing "10" pattern to fill last byte if needed
          if (out_bitcounter > 0 && out_bitcounter < 8 && out_bytecounter < 63) {
            for (uint8_t i = out_bitcounter; i < 8; i += 2) {
              packet_data[out_bytecounter] |= (1 << out_shift);
              out_shift--;
              packet_data[out_bytecounter] |= (0 << out_shift);
              if (out_shift == 0) {
                out_shift = 8;
              }
              out_shift--;
            }
            out_bytecounter++;
          }

          if (out_bytecounter < 63) {
            packet_data[out_bytecounter] = end_byte;
            out_bytecounter++;
          }

          while (out_bytecounter < 63) {
            packet_data[out_bytecounter] = 0xAA;
            out_bytecounter++;
          }

          ESP_LOGD("itho", "Send: %d times; %d delay, data: %s", transmit_count, retransmit_delay, format_hex_pretty(packet_data.data(), packet_data.size()).c_str());

          id(send_packet_data).execute(packet_data, transmit_count, retransmit_delay);

  # Script to send a command (Low/Medium/High - sends 3 times)
  - id: send_command
    mode: single
    parameters:
      command_byte: uint8_t
    then:
      - lambda: |-
          // Increment packet counter and log
          id(packet_counter)++;
          const char* command_name = 
            (command_byte == 0x02) ? "Low" :
            (command_byte == 0x03) ? "Medium" :
            (command_byte == 0x04) ? "High" : "Unknown";
          ESP_LOGI("itho", "Sending %s command (counter=%d)", command_name, id(packet_counter));
          id(last_command).publish_state(command_name);
          id(controller_name).publish_state("${device_name}");

          // Build command payload
          std::array<uint8_t, 12> payload;
          // Byte 0: device type
          payload[0] = id(device_type);
          // Bytes 1-3: deviceId
          payload[1] = id(my_device_id)[3];
          payload[2] = id(my_device_id)[4];
          payload[3] = id(my_device_id)[5];
          payload[4] = id(packet_counter);

          // Bytes 5-10: command bytes (ithoMessageLowCommandBytes, ithoMessageMediumCommandBytes, ithoMessageHighCommandBytes)
          payload[5] = 0x22;
          payload[6] = 0xF1;
          payload[7] = 0x03;
          payload[8] = 0x00;
          payload[9] = command_byte;
          payload[10] = 0x04;

          // Byte 11: CRC - sum of bytes 0-10 subtracted from 0
          uint8_t sum = 0;
          for (uint8_t i = 0; i < 11; i++) {
            sum += payload[i];
          }
          payload[11] = 0 - sum;

          id(send_payload).execute(payload.data(), payload.size(), 0xAC, 3, 40);


  # Script to send a join command (used for pairing - sends 3 times)
  - id: send_join_command
    mode: single
    then:
      - lambda: |-
          // Increment packet counter and log
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending Join command (counter=%d)", id(packet_counter));
          
          // Build command payload
          std::array<uint8_t, 21> payload;
          // Byte 0: device type
          payload[0] = id(device_type);
          // Bytes 1-3: deviceId
          payload[1] = id(my_device_id)[3];
          payload[2] = id(my_device_id)[4];
          payload[3] = id(my_device_id)[5];
          payload[4] = id(packet_counter);

          // Bytes 5-10: Join command bytes (ithoMessageJoinCommandBytes)
          payload[5] = 0x1F;
          payload[6] = 0xC9;
          payload[7] = 0x0C;
          payload[8] = 0x00;
          payload[9] = 0x22;
          payload[10] = 0xF1;

          // Bytes 11-13: deviceId again
          payload[11] = id(my_device_id)[3];
          payload[12] = id(my_device_id)[4];
          payload[13] = id(my_device_id)[5];

          // Bytes 14-16: Fixed values
          payload[14] = 0x01;
          payload[15] = 0x10;
          payload[16] = 0xE0;

          // Bytes 17-19: deviceId again
          payload[17] = id(my_device_id)[3];
          payload[18] = id(my_device_id)[4];
          payload[19] = id(my_device_id)[5];

          // Byte 20: Counter2 (CRC) - sum of bytes 0-19 subtracted from 0
          uint8_t sum = 0;
          for (int i = 0; i < 20; i++) sum += payload[i];
          payload[20] = (uint8_t)(0x100 - (sum & 0xFF));

          id(send_payload).execute(payload.data(), payload.size(), 0xCA, 3, 40);

  # Script to send a leave command (used for pairing - sends 3 times)
  - id: send_leave_command
    mode: single
    then:
      - lambda: |-
          // Increment packet counter and log
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending Leave command (counter=%d)", id(packet_counter));
          
          // Build command payload
          std::array<uint8_t, 15> payload;
          // Byte 0: device type
          payload[0] = id(device_type);
          // Bytes 1-3: deviceId
          payload[1] = id(my_device_id)[3];
          payload[2] = id(my_device_id)[4];
          payload[3] = id(my_device_id)[5];
          payload[4] = id(packet_counter);

          // Bytes 5-10: Leave command bytes (ithoMessageLeaveCommandBytes)
          payload[5] = 0x1F;
          payload[6] = 0xC9;
          payload[7] = 0x06;
          payload[8] = 0x00;
          payload[9] = 0x1F;
          payload[10] = 0xC9;

          // Bytes 11-13: deviceId again
          payload[11] = id(my_device_id)[3];
          payload[12] = id(my_device_id)[4];
          payload[13] = id(my_device_id)[5];

          // Byte 14: Counter2 (CRC) - sum of bytes 0-19 subtracted from 0
          uint8_t sum = 0;
          for (int i = 0; i < 14; i++) sum += payload[i];
          payload[14] = (uint8_t)(0x100 - (sum & 0xFF));

          // the leave command needs to be transmitted for 1 second
          id(send_payload).execute(payload.data(), payload.size(), 0xCA, 30, 4);

  # inspired by https://karlquinsland.com/esphome-dynamic-timer/
  - id: timer_tick
    # Start a new run after previous runs completes. This will happen until timer.stop() is called on us
    ##
    mode: queued
    then:
      # A single 'tick' is 1 second long
      - delay: 1s
      - lambda: |-
          // First, update the number of ticks
          id(timeout) -= 1;

          // Then check if we have timed out
          if (id(timeout) <= 0) {
            ESP_LOGD("itho", "timer finished");
            id(timer).publish_state("Off");
            // And finally, stop the ticking timer
            id(timer_tick).stop();
            ESP_LOGD("itho", "timer_tick now stopped!");
          }
          else {
            int minutes = id(timeout) / 60;
            int seconds = id(timeout) % 60;
            char buffer[20];
            sprintf(buffer, "%d:%02d", minutes, seconds);
            id(timer).publish_state(buffer);
            // make sure we run again..
            id(timer_tick).execute();
          }
