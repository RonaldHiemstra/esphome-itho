esphome:
  name: itho-ventilation
  friendly_name: ITHO ventilation
  on_boot:
    then:
      - lambda: |-
          get_mac_address_raw(id(my_device_id));
          ESP_LOGI("itho", "Device MAC: %s", format_hex_pretty(id(my_device_id), 6).c_str());

esp32:
  board: esp32dev
  framework:
    type: esp-idf

spi:
  clk_pin: GPIO18 # CC1101 SCK
  miso_pin: GPIO19 # CC1101 MISO/GDO1
  mosi_pin: GPIO23 # CC1101 MOSI

# Enable logging
logger:

mqtt:
  broker: !secret mqtt_broker
  username: !secret mqtt_username
  password: !secret mqtt_password
  log_topic: esp/logs/itho-ventilation

ota:
  - platform: esphome
    password: "f65ab2932751d08bf5775d8058830d88"

web_server:
   port: 80

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

# Store device ID for RF transmission
globals:
  # Device ID bytes (MAC address of device. Use last 3 bytes which are probably unique)
  - id: my_device_id
    type: uint8_t[6]
    restore_value: no
    initial_value: '{0, 0, 0, 0, 0, 0}'
  - id: device_type
    type: uint8_t
    restore_value: no
    initial_value: '22'  # 0x16 = 22 decimal, standard ITHO remote type
  - id: packet_counter
    type: uint8_t
    restore_value: yes
    initial_value: '0'
  - id: timeout
    type: int32_t
    restore_value: no
    initial_value: '0'
  - id: sync_bytes
    type: uint8_t[2]
    restore_value: no
    initial_value: '{0xAB, 0xFE}'  # Same as cc1101.sync1, cc1101.sync0
  - id: itho_header
    type: uint8_t[5]
    restore_value: no
    initial_value: '{0x00, 0xB3, 0x2A, 0xAB, 0x2A}'

# https://esphome.io/components/cc1101/
# Configuration based on IthoCC1101::initReceiveMessage()
# See: https://github.com/letscontrolit/ESPEasy/blob/15830d38268eb28c3fe234413a81f6cf015aeda9/lib/Itho/IthoCC1101.cpp#L238
cc1101:
  cs_pin: GPIO22
  # Base/carrier frequency: 868.299866MHz
  frequency: 868.2999MHz
  # 2-FSK modulation
  modulation_type: 2-FSK
  # Symbol rate: MDMCFG4=0x5A, MDMCFG3=0x83 = 38.3835 kBaud
  symbol_rate: 38383
  # Filter bandwidth: ~203kHz (based on MDMCFG4=0x5A)
  filter_bandwidth: 203kHz
  # Frequency deviation: DEVIATN=0x50 = 50.78125kHz
  fsk_deviation: 50kHz
  # Output power
  output_power: 10
  # Enable packet mode
  gdo0_pin: GPIO16
  packet_mode: true
  # Packet mode configuration
  num_preamble: 4  # 8 bytes; Note: ITHO expects 7 bytes
  sync_mode: 16/16  # MDMCFG2=0x02 = 16-bit sync word
  sync1: 0xAB # Same as global sync_bytes[0]
  sync0: 0xFE # Same as global sync_bytes[1]
  packet_length: 63  # Fixed packet length (sync bytes removed by CC1101)
  crc_enable: false  # CRC disabled in ITHO
  whitening: false   # Data whitening disabled
  on_packet:
    then:
      - lambda: |-
          // ITHO packet decoder based on IthoCC1101::messageDecode()
          // Decode Manchester-like encoding with 1-0 pattern every 8 bits

          if (x.size() != 63) {
            ESP_LOGW("itho", "Invalid packet length: %d", x.size());
            return;
          }

          for (int i = 0; i < sizeof(id(itho_header)); ++i) {
            if (x[i] != id(itho_header)[i]) {
              if (rssi > -100) {  // Silently ignore non ITHO packets with a rssi below 100 dBm
                ESP_LOGD("itho", "non itho message: %s", format_hex_pretty(x, x.size()).c_str());
              }
              return;
            }
          }

          // ESP_LOGD("itho", "raw message: %s", format_hex_pretty(x, x.size()).c_str());

          // Decoded data buffer
          uint8_t decoded[32] = {0};
          uint8_t decoded_len = 0;

          // Decoding parameters - start decoding after ITHO header
          const int STARTBYTE = sizeof(id(itho_header));
          uint8_t out_i = 0;         // byte index
          uint8_t out_j = 4;         // bit index (start at bit 4)
          uint8_t in_bitcounter = 0; // process per 10 input bits

          // Decode the packet starting from STARTBYTE
          for (int i = STARTBYTE; i < x.size(); i++) {
            for (int j = 7; j >= 0; j--) {
              // Select even bits (0, 2, 4, 6) for output
              if (in_bitcounter == 0 || in_bitcounter == 2 ||
                  in_bitcounter == 4 || in_bitcounter == 6) {
                uint8_t bit = (x[i] >> j) & 0x01;
                decoded[out_i] |= (bit << out_j);
                out_j++;
                if (out_j > 7) { out_j = 0; }
                if (out_j == 4) {
                  out_i++;
                  if (out_i >= 32) break;
                }
              }

              in_bitcounter++;
              if (in_bitcounter > 9) { in_bitcounter = 0; }
            }
            if (out_i >= 32) break;
          }
          decoded_len = out_i;

          // Log decoded packet
          ESP_LOGD("itho", "rssi: %.1f dBm, lqi: %u, Decoded (%d bytes): %s", rssi, lqi, decoded_len, format_hex_pretty(decoded, decoded_len).c_str());

          // Check for valid ITHO packet (min 14 bytes)
          if (decoded_len < 14) {
            ESP_LOGW("itho", "Decoded packet too short");
            return;
          }

          const char* command = nullptr;
          const char* device_name = nullptr;

          // Check if this is a status message from the unit (starts with 0x1A)
          // Format: 1A.94.D8.F9.94.D8.F9.XX.31.D9.11.00.06.YY...
          if (decoded[0] == 0x1A && decoded[12] == 0x06) {
            // ===== ALLOWED VENTILATION UNIT IDs LIST =====
            // Add your Itho ventilation unit IDs here with their names
            struct {
              uint8_t id[3];
              const char* name;
            } allowed_devices[] = {
              // UPDATE THESE WITH YOUR ACTUAL VENTILATION-UNIT IDs!
              {{0x94, 0xD8, 0xF9}, "Ventilatie unit"},
            };

            // Check if device ID is in allowed list
            for (const auto& device : allowed_devices) {
              if (memcmp(&decoded[1], device.id, 3) == 0) {
                device_name = device.name;
                break;
              }
            }

            if (device_name == nullptr) {
              ESP_LOGW("itho", "Ignored packet from unknown ventilation unit: %s", format_hex_pretty(&decoded[1], 3).c_str());
              return;  // Reject commands from unknown devices
            }

            // Byte 13 contains speed indicator
            // Percentage calculation: 0x20 (32) = 0%, 0x80 (128)+ = 100%
            uint8_t speed_byte = decoded[13];

            // Calculate percentage (0x20-0x80 mapped to 0-100%)
            float percentage = 0.0;
            if (speed_byte >= 0x80) {
              percentage = 100.0;
            } else if (speed_byte >= 0x20) {
              percentage = ((float)(speed_byte - 0x20) / (0x80 - 0x20)) * 100.0;
            }
            id(fan_speed).publish_state(percentage);

            // Categorize speed for text sensors
            // Ignore transient values during speed changes
            if (speed_byte >= 0x20) {
              if (speed_byte >= 0x80) {
                // >= 128: High
                command = "High";
              } else if (speed_byte >= 0x38) {
                // 56-127: Medium (position 2 auto or ramped up)
                command = "Medium";
              } else if (speed_byte >= 0x30) {
                // 48-55: Low (position 1)
                command = "Low";
              }
            }

            if (command != nullptr) {
              id(last_command).publish_state(command);
            }
          }
          // Remote command packets: check bytes 5-10 against command patterns
          // Based on IthoCC1101::checkIthoCommand() and command byte arrays
          // Low:    22 F1 03 00 02 04 (0x22, 0xF1, 0x03, 0x00, 0x02, 0x04)
          // Medium: 22 F1 03 00 03 04 (0x22, 0xF1, 0x03, 0x00, 0x03, 0x04)
          // High:   22 F1 03 00 04 04 (0x22, 0xF1, 0x03, 0x00, 0x04, 0x04)
          // Timer:  22 F3 03 00 00 0A (0x22, 0xF3, 0x03, 0x00, 0x00, 0x0A/14/1E)
          else if (decoded_len >= 11 && decoded[5] == 0x22 && decoded[7] == 0x03) {
            // ===== ALLOWED REMOTE IDs LIST =====
            // Add your Itho remote IDs here with their room names
            struct {
              uint8_t id[3];
              const char* name;
            } allowed_devices[] = {
              // UPDATE THESE WITH YOUR ACTUAL REMOTE IDs!
              {{0x51, 0x36, 0x35}, "Badkamer"},
              {{0xA4, 0xF0, 0x0F}, "ESP remote"},
            };

            // Check if device ID is in allowed list
            for (const auto& device : allowed_devices) {
              if (memcmp(&decoded[1], device.id, 3) == 0) {
                device_name = device.name;
                break;
              }
            }

            if (device_name == nullptr) {
              ESP_LOGW("itho", "Ignored packet from unknown remote unit: %s", format_hex_pretty(&decoded[1], 3).c_str());
              return;  // Reject commands from unknown devices
            }

            // Timer: byte[6]==0xF3, byte[9]==0x00, byte[10]==0x0A/0x14/0x1E (10, 20 or 30 minutes)
            if (decoded[6] == 0xF3 && decoded[9] == 0x00) {
              command = "Timer";
              id(timeout) = decoded[10] * 60;
              if (! id(timer_tick).is_running()) {
                id(timer_tick).execute();  // Start the timer
              }
            }
            // Low/Medium/High: byte[6]==0xF1, byte[10]==0x04
            else if (decoded[6] == 0xF1 && decoded[10] == 0x04) {
              id(timeout) = 0;  // Disable the timer
              // Distinguish by byte[9]
              if (decoded[9] == 0x02) {
                command = "Low";
              } else if (decoded[9] == 0x03) {
                command = "Medium";
              } else if (decoded[9] == 0x04) {
                command = "High";
              }
            }
          }

          // Update sensors for remote commands
          if (command != nullptr) {
            ESP_LOGI("itho", "Command: %s (Source: %s)", command, device_name);
            id(controller_name).publish_state(device_name);
            id(last_command).publish_state(command);
          }

# Sensors for ITHO status
sensor:
  - platform: template
    name: "Ventilation Speed"
    id: fan_speed
    unit_of_measurement: "%"
    icon: "mdi:fan"
    accuracy_decimals: 0

  - platform: uptime
    type: seconds
    name: Uptime Sensor

  - platform: wifi_signal
    name: "WiFi Signal Sensor"

# Text sensors for ITHO commands
text_sensor:
  - platform: template
    name: "Last Command"
    id: last_command
    icon: "mdi:fan-clock"

  - platform: template
    name: "Last Control Source"
    id: controller_name
    icon: "mdi:remote"

  - platform: template
    name: "Timer"
    id: timer
    icon: "mdi:timer"

# Buttons for pairing and control
button:
  - platform: template
    name: "Pair Remote"
    icon: "mdi:link-plus"
    on_press:
      - lambda: |-
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending Join command (counter=%d)", id(packet_counter));
      - script.execute:
          id: send_join_command

  - platform: template
    name: "Leave Remote"
    icon: "mdi:link-off"
    on_press:
      - lambda: |-
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending Leave command (counter=%d)", id(packet_counter));
      - script.execute:
          id: send_leave_command

  - platform: template
    name: "Low"
    icon: "mdi:fan-speed-1"
    on_press:
      - lambda: |-
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending Low command (counter=%d)", id(packet_counter));
      - script.execute:
          id: send_command
          command_byte: 0x02

  - platform: template
    name: "Medium"
    icon: "mdi:fan-speed-2"
    on_press:
      - lambda: |-
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending Medium command (counter=%d)", id(packet_counter));
      - script.execute:
          id: send_command
          command_byte: 0x03

  - platform: template
    name: "High"
    icon: "mdi:fan-speed-3"
    on_press:
      - lambda: |-
          id(packet_counter)++;
          ESP_LOGI("itho", "Sending High command (counter=%d)", id(packet_counter));
      - script.execute:
          id: send_command
          command_byte: 0x04

# Scripts
script:
  - id: send_packet_data
    mode: queued
    parameters:
      packet_data: uint8_t*
      packet_size: uint8_t
      max_repeat: uint8_t
      retransmit_delay: uint8_t
    then:
      - cc1101.send_packet:
          data: !lambda |-
            // Return the full packet data
            ESP_LOGD("rhi", "sending packet_data");
            return {packet_data, &packet_data[packet_size]};
      - delay: !lambda |-
          ESP_LOGD("rhi", "delay: %d", retransmit_delay);
          return retransmit_delay;
      - lambda: |-
          ESP_LOGD("rhi", "resend: %d", max_repeat);
          if (max_repeat > 1) {
            id(send_packet_data).execute(packet_data, packet_size, max_repeat - 1, retransmit_delay);
          } else if (max_repeat == 1) {
            id(send_packet_data).execute(packet_data, packet_size, 0, 0);  // last transmit; don't wait after transmit
          }


  - id: send_payload
    mode: single
    parameters:
      payload: uint8_t*
      payload_size: uint8_t
      max_repeat: uint8_t   # generate packet data once and transmit max_repeat times
      retransmit_delay: uint8_t
    then:
      - lambda: |-
          // Encode message with Manchester-like encoding
          // Start with message header (sync_bytes + header)
          // Note: CC1101 will automatically add 8 bytes of 0xAA preamble (num_preamble: 4)
          std::array<uint8_t, 63> packet_data = {0};
          for (int i = 0; i < sizeof(id(sync_bytes)); i++) {
            packet_data[i] = id(sync_bytes)[i];
          }
          for (int i = 0; i < sizeof(id(itho_header)); i++) {
            packet_data[sizeof(id(sync_bytes)) + i] = (id(itho_header)[i]);
          }
          // Encoded buffer starts after the sync + header)

          // Manchester-like encoding of payload
          // Pattern: for each data bit, insert 1-0 pattern every 8 bits
          uint8_t out_bytecounter = sizeof(id(sync_bytes)) + sizeof(id(itho_header));
          uint8_t out_bitcounter = 0;           // Bit position within current output byte (0-7)
          uint8_t out_patterncounter = 0;       // Bit counter to add "10" pattern after every 8 bits
          uint8_t bitSelect = 4;                // Bit position of the input byte (4-7, 0-3)
          uint8_t out_shift = 7;                // Bit shift for positioning in output byte (7-0)

          // Process each byte of payload data
          for (uint8_t dataByte = 0; dataByte < payload_size; dataByte++) {
            // Process all 8 bits of this data byte
            for (uint8_t dataBit = 0; dataBit < 8; dataBit++) {
              // Check if new output byte is needed
              if (out_bitcounter == 8) {
                out_bytecounter++;
                out_bitcounter = 0;
                if (out_bytecounter >= 63) {
                  ESP_LOGW("itho", "too much data to encode");
                  return;
                }
              }

              // Insert "10" pattern every 8 bits
              if (out_patterncounter == 8) {
                out_patterncounter = 0;
                packet_data[out_bytecounter] |= (1 << out_shift);
                out_shift--;
                out_bitcounter++;
                packet_data[out_bytecounter] |= (0 << out_shift);
                if (out_shift == 0) {
                  out_shift = 8;
                }
                out_shift--;
                out_bitcounter++;
              }

              // Check if new output byte is needed (after pattern insertion)
              if (out_bitcounter == 8) {
                out_bytecounter++;
                out_bitcounter = 0;
                if (out_bytecounter >= 63) {
                  ESP_LOGW("itho", "too much data to encode");
                  return;
                }
              }

              // Extract bit from input data
              uint8_t bit = (payload[dataByte] & (1 << bitSelect)) >> bitSelect;
              bitSelect++;
              if (bitSelect == 8) {
                bitSelect = 0;
              }

              // Write the even bit (data bit)
              packet_data[out_bytecounter] |= (bit << out_shift);
              out_shift--;
              out_bitcounter++;
              out_patterncounter++;

              // Write the odd bit (inverted data bit)
              bit = ~bit & 0x01;
              packet_data[out_bytecounter] |= (bit << out_shift);
              if (out_shift == 0) {
                out_shift = 8;
              }
              out_shift--;
              out_bitcounter++;
              out_patterncounter++;
            }
          }

          // Add closing "10" pattern to fill last byte if needed
          if (out_bitcounter > 0 && out_bitcounter < 8 && out_bytecounter < 63) {
            for (uint8_t i = out_bitcounter; i < 8; i += 2) {
              packet_data[out_bytecounter] |= (1 << out_shift);
              out_shift--;
              packet_data[out_bytecounter] |= (0 << out_shift);
              if (out_shift == 0) {
                out_shift = 8;
              }
              out_shift--;
            }
            out_bytecounter++;
          }

          if (out_bytecounter < 63) {
            packet_data[out_bytecounter] = 0xAC;
            out_bytecounter++;
          }

          while (out_bytecounter < 63) {
            packet_data[out_bytecounter] = 0xAA;
            out_bytecounter++;
          }

          ESP_LOGD("itho", "size: %d, raw packet: %s", out_bytecounter, format_hex_pretty(packet_data.data(), packet_data.size()).c_str());

          id(send_packet_data).execute(packet_data.data(), packet_data.size(), max_repeat, retransmit_delay);

  # Script to send a command (Low/Medium/High - sends 3 times)
  - id: send_command
    mode: single
    parameters:
      command_byte: uint8_t
    then:
      - lambda: |-
          // Build command payload
          std::array<uint8_t, 12> payload;
          // Byte 0: device type
          payload[0] = id(device_type);
          // Bytes 1-3: deviceId
          payload[1] = id(my_device_id)[3];
          payload[2] = id(my_device_id)[4];
          payload[3] = id(my_device_id)[5];
          payload[4] = id(packet_counter);

          // Bytes 5-10: command bytes (ithoMessageLowCommandBytes, ithoMessageMediumCommandBytes, ithoMessageHighCommandBytes)
          payload[5] = 0x22;
          payload[6] = 0xF1;
          payload[7] = 0x03;
          payload[8] = 0x00;
          payload[9] = command_byte;
          payload[10] = 0x04;

          // Byte 11: CRC - sum of bytes 0-10 subtracted from 0
          uint8_t sum = 0;
          for (uint8_t i = 0; i < 11; i++) {
            sum += payload[i];
          }
          payload[11] = 0 - sum;

          id(send_payload).execute(payload.data(), payload.size(), 3, 40);


  # Script to send a join command (used for pairing - sends 3 times)
  - id: send_join_command
    mode: single
    then:
      - lambda: |-
          // Build command payload
          std::array<uint8_t, 21> payload;
          // Byte 0: device type
          payload[0] = id(device_type);
          // Bytes 1-3: deviceId
          payload[1] = id(my_device_id)[3];
          payload[2] = id(my_device_id)[4];
          payload[3] = id(my_device_id)[5];
          payload[4] = id(packet_counter);

          // Bytes 5-10: Join command bytes (ithoMessageJoinCommandBytes)
          payload[5] = 0x1F;
          payload[6] = 0xC9;
          payload[7] = 0x0C;
          payload[8] = 0x00;
          payload[9] = 0x22;
          payload[10] = 0xF1;

          // Bytes 11-13: deviceId again
          payload[11] = id(my_device_id)[3];
          payload[12] = id(my_device_id)[4];
          payload[13] = id(my_device_id)[5];

          // Bytes 14-16: Fixed values
          payload[14] = 0x01;
          payload[15] = 0x10;
          payload[16] = 0xE0;

          // Bytes 17-19: deviceId again
          payload[17] = id(my_device_id)[3];
          payload[18] = id(my_device_id)[4];
          payload[19] = id(my_device_id)[5];

          // Byte 20: Counter2 (CRC) - sum of bytes 0-19 subtracted from 0
          uint8_t sum = 0;
          for (int i = 0; i < 20; i++) sum += payload[i];
          payload[20] = (uint8_t)(0x100 - (sum & 0xFF));

          id(send_payload).execute(payload.data(), payload.size(), 3, 40);

  # Script to send a leave command (used for pairing - sends 3 times)
  - id: send_leave_command
    mode: single
    then:
      - lambda: |-
          // Build command payload
          std::array<uint8_t, 15> payload;
          // Byte 0: device type
          payload[0] = id(device_type);
          // Bytes 1-3: deviceId
          payload[1] = id(my_device_id)[3];
          payload[2] = id(my_device_id)[4];
          payload[3] = id(my_device_id)[5];
          payload[4] = id(packet_counter);

          // Bytes 5-10: Leave command bytes (ithoMessageLeaveCommandBytes)
          payload[5] = 0x1F;
          payload[6] = 0xC9;
          payload[7] = 0x06;
          payload[8] = 0x00;
          payload[9] = 0x1F;
          payload[10] = 0xC9;

          // Bytes 11-13: deviceId again
          payload[11] = id(my_device_id)[3];
          payload[12] = id(my_device_id)[4];
          payload[13] = id(my_device_id)[5];

          // Byte 14: Counter2 (CRC) - sum of bytes 0-19 subtracted from 0
          uint8_t sum = 0;
          for (int i = 0; i < 14; i++) sum += payload[i];
          payload[14] = (uint8_t)(0x100 - (sum & 0xFF));

          // the leave command needs to be transmitted for 1 second
          id(send_payload).execute(payload.data(), payload.size(), 30, 4);


  # inspired by https://karlquinsland.com/esphome-dynamic-timer/
  - id: timer_tick
    # Start a new run after previous runs completes. This will happen until timer.stop() is called on us
    ##
    mode: queued
    then:
      # A single 'tick' is 1 second long
      - delay: 1s
      - lambda: |-
          // First, update the number of ticks
          id(timeout) -= 1;

          // Then check if we have timed out
          if (id(timeout) <= 0) {
            ESP_LOGD("itho", "timer finished");
            id(timer).publish_state("Off");
            // And finally, stop the ticking timer
            id(timer_tick).stop();
            ESP_LOGD("itho", "timer_tick now stopped!");
          }
          else {
            int minutes = id(timeout) / 60;
            int seconds = id(timeout) % 60;
            char buffer[20];
            sprintf(buffer, "%d:%02d", minutes, seconds);
            id(timer).publish_state(buffer);
            // make sure we run again..
            id(timer_tick).execute();
          }
